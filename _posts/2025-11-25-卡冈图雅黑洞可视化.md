---
title: '2025/11/25'
date: 2025-11-25
permalink: /posts/2025/11/blog-post-6/
mathjax: true
tags:
  - ç¢ç¢å¿µ
  - ç ”ç©¶è¯¾é¢˜
---

å¾ˆå¤šäººéƒ½çŸ¥é“æ˜Ÿé™…ç©¿è¶Šé‡Œçš„é»‘æ´å½¢è±¡, Gemini 3.0 å·²ç»å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¾ˆæ–¹ä¾¿åœ°å¯è§†åŒ–ä»–äº†ğŸ¤—

æ„Ÿè§‰åŒ…è£…åŒ…è£…éƒ½èƒ½å½“åšå£çº¸å‘¢, å†åŠ å…¥ä¸€ç‚¹éšæœºäº‹ä»¶ä»€ä¹ˆçš„, æˆ–è€…å†åŠ å…¥ä¸€ç‚¹äº’åŠ¨æ€§è¦ç´ ä»€ä¹ˆçš„, æ„Ÿè§‰çœŸçš„å¥½å¥½ç©çš„.

<div style="text-align: center; margin: 2em 0;">
  <a href="/BH+disk/" target="_blank" class="btn btn--info btn--large">
    ğŸª å¡å†ˆå›¾é›…é»‘æ´å…‰çº¿è¿½è¸ªå¯è§†åŒ–
  </a>
</div>


é¡ºå¸¦é™„ä¸Šæºç , æ¬¢è¿ä½“éªŒ:

```html
---
layout: null
permalink: /BH+disk/
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Black Hole - Cinematic Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none;}

        /* --- UI Container --- */
        #ui-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            z-index: 10;
            user-select: none;
            perspective: 1000px;
        }

        /* --- Frosted Glass Card (UIå¡ç‰‡æ ·å¼) --- */
        .glass-card {
            background: rgba(12, 18, 24, 0.45); 
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(100, 200, 255, 0.15);
            border-top: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 14px; /* åœ†è§’ç¨å¾®å‡å°ä»¥é€‚é…ç´§å‡‘æ„Ÿ */
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.6),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            
            /* [UPDATE] ç¼©å‡å†…è¾¹è·ä»¥é™ä½é«˜åº¦ */
            padding: 16px 20px; 
            
            color: rgba(255, 255, 255, 0.95);
            width: 170px; /* ç¨å¾®åŠ å®½ä¸€ç‚¹ç‚¹ä»¥å®¹çº³æ›´é•¿çš„æ–‡å­— */
            pointer-events: auto;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            text-align: center;
        }

        .glass-card:hover {
            transform: translateY(-2px);
            background: rgba(15, 22, 30, 0.55);
            border-color: rgba(100, 200, 255, 0.4);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
        }

        /* --- Sci-Fi Typography --- */
        h1 {
            /* [UPDATE] å‡å°‘æ ‡é¢˜ä¸‹è¾¹è· */
            margin: 0 0 10px 0;
            font-family: 'Courier New', Courier, monospace; 
            font-weight: 800; 
            /* [UPDATE] å­—ä½“ç¨å¾®æ”¹å° */
            font-size: 20px; 
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, #e0f7fa 0%, #4dd0e1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(77, 208, 225, 0.5);
            border-bottom: 2px solid rgba(77, 208, 225, 0.2); 
            padding-bottom: 8px;
        }

        .controls-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 12.5px; /* å­—ä½“æ”¹å°ä»¥é€‚é…ç´§å‡‘å¸ƒå±€ */
            font-weight: 700; 
            letter-spacing: 0.5px;
            /* [UPDATE] å‡å°‘è¡Œé«˜ï¼Œè®©æ–‡å­—æ›´ç´§å‡‘ */
            line-height: 1.8; 
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls-list li {
            display: flex;
            align-items: center;
            justify-content: flex-start; /* æ–‡å­—å·¦å¯¹é½æˆ–è€…å±…ä¸­ï¼Œè¿™é‡Œé€‰å·¦å¯¹é½çœ‹èµ·æ¥æ›´æ•´é½ï¼Œæˆ–è€…å±…ä¸­ä¹Ÿå¯ä»¥ */
            justify-content: center;
            color: rgba(220, 240, 255, 0.9); 
            width: 100%;
            white-space: nowrap; /* é˜²æ­¢æ¢è¡Œ */
        }

        .icon {
            margin-right: 6px;
            font-size: 12px;
            color: #4dd0e1;
            text-shadow: 0 0 8px rgba(77, 208, 225, 0.6); 
        }

        /* --- Toggle Switch --- */
        .toggle-container {
            /* [UPDATE] å‡å°‘é¡¶éƒ¨è¾¹è· */
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            font-weight: 800; 
            color: rgba(180, 210, 220, 0.9);
            letter-spacing: 1px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 32px; /* ç¨å¾®ç¼©å°å¼€å…³ */
            height: 16px;
        }

        .switch input { opacity: 0; width: 0; height: 0; }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(255, 255, 255, 0.15);
            transition: .3s;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 10px;
            width: 10px;
            left: 2px;
            bottom: 2px;
            background-color: rgba(255,255,255,0.9);
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: rgba(77, 208, 225, 0.4);
            border-color: #4dd0e1;
        }

        input:checked + .slider:before {
            transform: translateX(16px);
            background-color: #4dd0e1;
            box-shadow: 0 0 8px #4dd0e1;
        }

        /* Status Dot */
        .status-dot {
            position: absolute;
            top: 18px; /* æ ¹æ®æ–°çš„paddingè°ƒæ•´ä½ç½® */
            right: 16px;
            width: 6px;
            height: 6px;
            background-color: #4dd0e1;
            border-radius: 50%;
            box-shadow: 0 0 8px #4dd0e1;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="glass-card">
            <div class="status-dot"></div>
            <h1>GARGANTUA</h1>
            <!-- [UPDATE] æ›´æ–°åçš„æ–‡æ¡ˆ -->
            <ul class="controls-list">
                <li><span class="icon">â—</span> å·¦é”®æ‹–åŠ¨æ—‹è½¬è§†è§’</li>
                <li><span class="icon">âœ¥</span> å³é”®æ‹–åŠ¨å¹³ç§»ä½ç½®</li>
                <li><span class="icon">â†”</span> é¼ æ ‡æ»šè½®ç¼©æ”¾é•œå¤´</li>
            </ul>
            
            <div class="toggle-container">
                <span>DYNAMICAL</span>
                <label class="switch">
                    <input type="checkbox" id="anim-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½®é¡¹ (å¯ä»¥åœ¨è¿™é‡Œè°ƒæ•´åŸºæœ¬å‡ ä½•å‚æ•°) ---
        const config = {
            blackHoleRadius: 1.0,      // [è§†è§‰] é»‘æ´è§†ç•ŒåŠå¾„ (Schwarzschild Radius)
            diskInner: 3.0,            // [è§†è§‰] å¸ç§¯ç›˜å†…ç¼˜åŠå¾„ (ç†è®ºä¸Šæœ€å°ç¨³å®šè½¨é“æ˜¯3.0, è§†è§‰ä¸Šä¸ºäº†ç¾è§‚å–å°ä¸€ç‚¹)
            diskOuter: 10.0,           // [è§†è§‰] å¸ç§¯ç›˜å¤–ç¼˜åŠå¾„
            gravitationalStrength: 1.3 // [ç‰©ç†] å¼•åŠ›é€é•œå¼ºåº¦ç³»æ•° (å½±å“å…‰çº¿å¼¯æ›²ç¨‹åº¦)
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.5;    // [äº¤äº’] æœ€å°ç¼©æ”¾è·ç¦» (è¶Šå°è¶Šèƒ½è´´è¿‘é»‘æ´)
        controls.maxDistance = 60.0;   // [äº¤äº’] æœ€å¤§ç¼©æ”¾è·ç¦» (å…è®¸æ‹‰è¿œçœ‹æ˜Ÿç©º)
        controls.enablePan = true; 
        controls.panSpeed = 0.5; 

        // --- Shader æè´¨å®šä¹‰ (æ ¸å¿ƒæ¸²æŸ“é€»è¾‘) ---
        const blackHoleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                iCameraPos: { value: camera.position },
                iCameraDir: { value: new THREE.Vector3() }, 
                iCameraUp: { value: camera.up }, 
                iFov: { value: camera.fov },
                
                uDiskInner: { value: config.diskInner },
                uDiskOuter: { value: config.diskOuter },
                uBhRadius: { value: config.blackHoleRadius }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float iTime;
                uniform vec2 iResolution;
                uniform vec3 iCameraPos;
                uniform vec3 iCameraDir; 
                uniform vec3 iCameraUp;
                uniform float iFov;

                uniform float uDiskInner;
                uniform float uDiskOuter;
                uniform float uBhRadius;

                varying vec2 vUv;

                // [æ€§èƒ½] æœ€å¤§å…‰çº¿è¿½è¸ªæ­¥æ•° (è¶Šé«˜ç”»è´¨è¶Šå¥½, ä½†è¶Šå¡)
                #define MAX_STEPS 150
                // [ç‰©ç†] å…‰çº¿è¿½è¸ªçš„æœ€å¤§è·ç¦» (è¶…è¿‡è¿™ä¸ªè·ç¦»è®¤ä¸ºå…‰çº¿é€ƒé€¸åˆ°èƒŒæ™¯)
                #define MAX_DIST 150.0
                #define PI 3.14159265359

                // --- éšæœºå™ªå£°å‡½æ•°åº“ ---
                float hash(vec2 p) {
                    p = fract(p * vec2(123.34, 456.21));
                    p += dot(p, p + 45.32);
                    return fract(p.x * p.y);
                }
                
                float hash3(vec3 p) {
                    p = fract(p * 0.3183099 + .1);
                    p *= 17.0;
                    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    float a = hash(i); float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0));
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }
                
                // åˆ†å½¢å¸ƒæœ—è¿åŠ¨ (ç”¨äºç”Ÿæˆå¸ç§¯ç›˜äº‘é›¾çº¹ç†)
                float fbm(vec2 p) {
                    float f = 0.0; float w = 0.5; float scale = 1.0;
                    for (int i = 0; i < 4; i++) {
                        f += w * noise(p * scale); scale *= 2.0; w *= 0.5;
                    }
                    return f;
                }

                // --- æ˜Ÿç©ºèƒŒæ™¯ç”Ÿæˆå‡½æ•° ---
                vec3 getStarField(vec3 dir) {
                    vec3 col = vec3(0.0);
                    
                    // [è§†è§‰] èƒŒæ™¯ç¼“æ…¢æ—‹è½¬é€Ÿåº¦
                    float theta = iTime * 0.012;
                    float cs = cos(theta);
                    float sn = sin(theta);
                    mat2 rot = mat2(cs, -sn, sn, cs);
                    dir.xz = rot * dir.xz;
                    dir.xy = rot * dir.xy;

                    // åŒå±‚æ˜Ÿç©ºå¾ªç¯ (i=1: å¤§æ˜Ÿ/è¿‘æ˜Ÿ, i=2: å°æ˜Ÿ/è¿œæ˜Ÿ)
                    for(float i=1.0; i<=2.0; i++) {
                        // [è§†è§‰] æ˜Ÿæ˜Ÿç½‘æ ¼ç¼©æ”¾ (æ•°å­—è¶Šå¤§ï¼Œç½‘æ ¼è¶Šå¯†ï¼Œæ˜Ÿæ˜Ÿè¶Šå°)
                        float scale = (i == 1.0) ? 20.0 : 45.0; 
                        vec3 p = dir * scale;
                        
                        vec3 id = floor(p);
                        vec3 local = fract(p) - 0.5;
                        
                        float seed = hash3(id + i * 123.45);
                        
                        // [å…³é”®è°ƒèŠ‚] æ˜Ÿæ˜Ÿç”Ÿæˆé˜ˆå€¼ (0.0 - 1.0)
                        // å€¼è¶Šå°ï¼Œé€šè¿‡ç‡è¶Šé«˜ï¼Œæ˜Ÿæ˜Ÿè¶Šå¤šã€‚
                        // åŸæ¥æ˜¯ 0.7/0.5, ç°åœ¨é™ä½åˆ° 0.4/0.1 ä»¥å¤§å¹…å¢åŠ å¯†åº¦
                        float threshold = (i == 1.0) ? 0.25 : 0.1;
                        
                        if (seed > threshold) {
                            vec3 posOffset = vec3(
                                fract(seed * 12.5) - 0.5,
                                fract(seed * 34.1) - 0.5,
                                fract(seed * 56.7) - 0.5
                            ) * 0.6; 
                            
                            float dist = length(local - posOffset);
                            
                            // [è§†è§‰] æ˜Ÿæ˜Ÿå¤§å°
                            float sizeBase = (i == 1.0) ? 0.05 : 0.03;
                            float size = sizeBase + 0.04 * fract(seed * 10.0);
                            
                            // æ˜Ÿæ˜Ÿå½¢çŠ¶è®¡ç®— (æ ¸å¿ƒ+å…‰æ™•)
                            float core = smoothstep(size, size * 0.2, dist); 
                            float glow = exp(-dist * 8.0 / size) * 0.5;
                            float starShape = core + glow;

                            // [è§†è§‰] å‘¼å¸é—ªçƒé€Ÿåº¦ä¸å¹…åº¦
                            float pulseSpeed = 0.5 + 2.0 * fract(seed * 99.0);
                            float pulse = 0.6 + 0.4 * sin(iTime * pulseSpeed + seed * 6.28);
                            
                            // [è§†è§‰] æ’æ˜Ÿå…‰è°±é¢œè‰² (å·²å¢å¼ºé¥±å’Œåº¦)
                            vec3 tint;
                            float colorSeed = fract(seed * 43.2);
                            if (colorSeed < 0.2) tint = vec3(0.4, 0.7, 1.0); // è“è¶…å·¨æ˜Ÿ (æ›´è“)
                            else if (colorSeed < 0.4) tint = vec3(0.6, 0.9, 1.0); // è“ç™½æ˜Ÿ
                            else if (colorSeed < 0.7) tint = vec3(1.0, 0.95, 0.8); // é»„çŸ®æ˜Ÿ (å¤ªé˜³ç±»)
                            else if (colorSeed < 0.9) tint = vec3(1.0, 0.7, 0.4); // æ©™å·¨æ˜Ÿ
                            else tint = vec3(1.0, 0.3, 0.2); // çº¢çŸ®æ˜Ÿ (æ›´çº¢)
                            
                            // [è§†è§‰] äº®åº¦å¼ºåº¦
                            float intensity = (i == 1.0) ? 3.0 : 1.5;
                            
                            col += tint * starShape * pulse * intensity;
                        }
                    }
                    return col;
                }

                // --- å¸ç§¯ç›˜é¢œè‰²è®¡ç®—å‡½æ•° ---
                vec4 getDiskColor(vec3 pos, float distToCenter) {
                    // èŒƒå›´å‰”é™¤
                    if (distToCenter < uDiskInner - 0.1 || distToCenter > uDiskOuter + 1.0) return vec4(0.0);
                    
                    float angle = atan(pos.z, pos.x);
                    // [ç‰©ç†] å¼€æ™®å‹’æ—‹è½¬é€Ÿåº¦ (è¶Šè¿‘è¶Šå¿«)
                    float speed = 3.5 / (distToCenter * 0.5 + 0.1); 
                    float rotAngle = angle + iTime * speed * 0.5;
                    
                    // ç”Ÿæˆäº‘é›¾å™ªç‚¹
                    float gas = fbm(vec2(distToCenter * 1.2, rotAngle * 3.5));
                    // ç”Ÿæˆç¯çŠ¶ç»“æ„
                    float ringPattern = sin(distToCenter * 5.0 + gas * 2.5); 
                    ringPattern = smoothstep(-0.4, 0.94, ringPattern);

                    float intensity = (0.4 + 0.6 * gas) * (0.3 + 0.7 * ringPattern);
                    
                    // è¾¹ç¼˜æ·¡å‡ºå¤„ç†
                    float outerFade = smoothstep(uDiskOuter, uDiskOuter - 3.0, distToCenter);
                    float innerFade = smoothstep(uDiskInner - 0.2, uDiskInner + 0.8, distToCenter);
                    
                    // [è§†è§‰] å¸ç§¯ç›˜é¢œè‰²é…ç½® (å¼€å°”æ–‡è‰²æ¸©æ¨¡æ‹Ÿ)
                    vec3 colInner = vec3(1.0, 0.95, 0.9); // å†…åœˆ: ç‚½çƒ­ç™½
                    vec3 colMid   = vec3(1.0, 0.6, 0.2);  // ä¸­åœˆ: é‡‘æ©™è‰²
                    vec3 colOuter = vec3(0.8, 0.1, 0.05); // å¤–åœˆ: æš—çº¢è‰²
                    
                    float t = (distToCenter - uDiskInner) / (uDiskOuter - uDiskInner);
                    vec3 baseColor = mix(colInner, colMid, smoothstep(0.0, 0.3, t));
                    baseColor = mix(baseColor, colOuter, smoothstep(0.3, 1.0, t));

                    // [ç‰©ç†] å¤šæ™®å‹’é¢‘ç§» (Relativistic Beaming)
                    // å·¦ä¾§æœå‘è§‚å¯Ÿè€…å˜äº®å˜è“ï¼Œå³ä¾§è¿œç¦»å˜æš—å˜çº¢
                    vec3 velocity = normalize(vec3(-pos.z, 0.0, pos.x));
                    vec3 viewDir = normalize(pos - iCameraPos);
                    float doppler = dot(velocity, viewDir);
                    
                    float beam = 1.0 + doppler * 0.6;
                    beam = max(0.2, beam); 

                    vec3 shiftColor = baseColor;
                    if (doppler > 0.0) shiftColor += vec3(0.1, 0.1, 0.2) * doppler;
                    else shiftColor *= vec3(1.0, 0.9, 0.8);
                    
                    float alpha = innerFade * outerFade * intensity;
                    return vec4(shiftColor * beam * 2.0, alpha);
                }

                void main() {
                    // UV åæ ‡æ ‡å‡†åŒ– (-1 åˆ° 1)
                    vec2 uv = vUv * 2.0 - 1.0;
                    uv.x *= iResolution.x / iResolution.y;

                    // æ‘„åƒæœºåæ ‡ç³»æ„å»º
                    vec3 camPos = iCameraPos;
                    vec3 camDir = normalize(iCameraDir); 
                    vec3 camRight = normalize(cross(camDir, iCameraUp));
                    vec3 camUp = cross(camRight, camDir);
                    
                    float fovRad = iFov * PI / 180.0;
                    float focalLength = 1.0 / tan(fovRad * 0.5);
                    vec3 rayDir = normalize(camRight * uv.x + camUp * uv.y + camDir * focalLength);

                    // å…‰çº¿è¿½è¸ªåˆå§‹åŒ–
                    vec3 currentPos = camPos;
                    vec3 currentDir = rayDir;
                    vec3 accColor = vec3(0.0); // ç´¯ç§¯é¢œè‰² (å¸ç§¯ç›˜)
                    float accAlpha = 0.0;      // ç´¯ç§¯é€æ˜åº¦
                    float glow = 0.0;          // è§†ç•Œå‘¨å›´çš„å…‰æ™•
                    
                    bool escaped = false; // æ ‡è®°å…‰çº¿æ˜¯å¦é€ƒé€¸åˆ°æ— ç©·è¿œ

                    // --- Ray Marching ä¸»å¾ªç¯ ---
                    for(int i = 0; i < MAX_STEPS; i++) {
                        float r = length(currentPos);
                        
                        // 1. æ’å‡»é»‘æ´è§†ç•Œ
                        if (r < uBhRadius) {
                            escaped = false; 
                            break; 
                        }
                        // 2. é€ƒé€¸åˆ°èƒŒæ™¯
                        if (r > MAX_DIST) {
                            escaped = true;
                            break;
                        }

                        // 3. å¼•åŠ›å¼¯æ›²è®¡ç®— (ç‰›é¡¿è¿‘ä¼¼ï¼Œå…¼é¡¾æ€§èƒ½ä¸æ•ˆæœ)
                        float step = max(0.04, r * 0.08); // è‡ªé€‚åº”æ­¥é•¿
                        vec3 force = -normalize(currentPos) * (1.5 / (r * r));
                        currentDir += force * step;
                        currentDir = normalize(currentDir);
                        vec3 nextPos = currentPos + currentDir * step;
                        
                        // 4. å¸ç§¯ç›˜æ±‚äº¤ (æ£€æµ‹æ˜¯å¦ç©¿è¿‡ Y=0 å¹³é¢)
                        if ((currentPos.y > 0.0 && nextPos.y < 0.0) || (currentPos.y < 0.0 && nextPos.y > 0.0)) {
                            float t = (0.0 - currentPos.y) / (nextPos.y - currentPos.y);
                            vec3 hitPos = currentPos + (nextPos - currentPos) * t;
                            float hitDist = length(hitPos);
                            vec4 diskCol = getDiskColor(hitPos, hitDist);
                            if (diskCol.a > 0.0) {
                                float stepAlpha = diskCol.a * 0.8; 
                                accColor += diskCol.rgb * (1.0 - accAlpha) * stepAlpha;
                                accAlpha += stepAlpha;
                            }
                        }
                        
                        // ç´¯ç§¯å…‰æ™• (æ¥è¿‘è§†ç•Œæ—¶å¢åŠ )
                        glow += 0.01 / (pow(r, 4.0) + 0.1);

                        currentPos = nextPos;
                        // å¦‚æœå¸ç§¯ç›˜ä¸é€æ˜åº¦å·²æ»¡ï¼Œæå‰åœæ­¢
                        if (accAlpha > 0.98) {
                            escaped = true; // å®é™…ä¸Šè¢«ç›˜æŒ¡ä½äº†ï¼Œä½†ä¸ºäº†é€»è¾‘ç»Ÿä¸€ï¼Œè§†ä¸ºç»“æŸ
                            break;
                        }
                    }

                    vec3 finalColor = accColor;

                    // --- æ··åˆæ˜Ÿç©ºèƒŒæ™¯ ---
                    // åªæœ‰å½“å…‰çº¿æ²¡æœ‰æ‰è¿›é»‘æ´æ—¶ï¼Œæ‰æ¸²æŸ“èƒŒæ™¯
                    if (escaped) {
                        // ä½¿ç”¨æœ€ç»ˆå¼¯æ›²çš„å…‰çº¿æ–¹å‘é‡‡æ ·æ˜Ÿç©º -> è‡ªåŠ¨å®ç°å¼•åŠ›é€é•œæ•ˆæœ
                        vec3 starColor = getStarField(currentDir);
                        finalColor += starColor * (1.0 - accAlpha);
                    }
                    
                    // æ·»åŠ å…‰æ™•é¢œè‰²
                    vec3 glowColor = mix(vec3(1.0, 0.5, 0.2), vec3(0.5, 0.8, 1.0), 1.0/(glow+1.0));
                    finalColor += glowColor * glow * 0.025; 

                    // --- åå¤„ç† (Tone Mapping & Color Grading) ---
                    finalColor *= 0.8; // æ›å…‰è°ƒæ•´
                    // ACES Filmic Tone Mapping æ‹Ÿåˆæ›²çº¿
                    float a = 2.51; float b = 0.03; float c = 2.43; float d = 0.59; float e = 0.14;
                    finalColor = clamp((finalColor * (a * finalColor + b)) / (finalColor * (c * finalColor + d) + e), 0.0, 1.0);
                    finalColor = pow(finalColor, vec3(1.0 / 2.2)); // Gamma æ ¡æ­£
                    
                    // æ™•å½± (Vignette) - å››è§’å‹æš—
                    float distFromCenter = length(uv);
                    finalColor *= smoothstep(2.2, 0.6, distFromCenter);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, blackHoleMaterial);
        mesh.frustumCulled = false; 
        scene.add(mesh);

        const clock = new THREE.Clock();

        let isAnimating = true;
        let shaderTime = 0;
        
        const toggleSwitch = document.getElementById('anim-toggle');
        toggleSwitch.addEventListener('change', (e) => {
            isAnimating = e.target.checked;
        });

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (isAnimating) {
                shaderTime += delta;
            }

            blackHoleMaterial.uniforms.iTime.value = shaderTime;
            blackHoleMaterial.uniforms.iResolution.value.set(renderer.domElement.width, renderer.domElement.height);
            blackHoleMaterial.uniforms.iCameraPos.value.copy(camera.position);
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            blackHoleMaterial.uniforms.iCameraDir.value.copy(camDir);
            blackHoleMaterial.uniforms.iCameraUp.value.copy(camera.up);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            blackHoleMaterial.uniforms.iFov.value = camera.fov;
        });

        animate();
    </script>
</body>
</html>
```

