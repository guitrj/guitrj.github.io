---
title: '2025/11/25'
date: 2025-11-25
permalink: /posts/2025/11/blog-post-5/
mathjax: true
tags:
  - ç¢ç¢å¿µ
  - ç ”ç©¶è¯¾é¢˜
---

ä»Šå¤©å¹²äº†ä¸ªå¾ˆæœ‰æ„æ€çš„ä¸œè¥¿, å¯ä»¥ä¸€è¡Œä»£ç ä¸å†™é€šè¿‡ Gemini 3.0 å®Œæˆ! 

> ğŸ“¢ ç½‘é¡µéœ€è¦è¯»å–ä½ çš„æ‘„åƒå¤´ä¿¡æ¯, é€šè¿‡æ‘„åƒå¤´è¯†åˆ«ä½ çš„æ‰‹æ¡æ‹³ (ä¼¸å±•) æ¥æ”¶ç¼© (æ•£å¼€) ç²’å­, æ‰€ä»¥éœ€è¦é€šè¿‡ä¸€æ¬¡æƒé™!

<div style="text-align: center; margin: 2em 0;">
  <a href="/particles/" target="_blank" class="btn btn--info btn--large">
    ğŸ”® ä½“éªŒ 3D ç²’å­äº¤äº’æ¼”ç¤º
  </a>
</div>

é¡ºå¸¦é™„ä¸Šæºç , æ¬¢è¿ä½“éªŒ:

```html
---
layout: null
permalink: /particles/
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ v4.4 (Slow Breath & Comments)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; visibility: hidden; width: 320px; height: 240px; transform: scaleX(-1); }
        
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(10, 10, 15, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 24px;
            border-radius: 20px;
            width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            transition: opacity 0.3s;
        }

        .btn-shape {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            padding: 8px 14px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        .btn-shape:hover, .btn-shape.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }
        .btn-shape.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.6);
            color: #e0f2fe;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            pointer-events: none;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #cam-preview {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 135px;
            z-index: 5;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            background: #000;
            opacity: 0.7;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }
        #cam-preview:hover { opacity: 1; }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div class="text-gray-400 text-xs tracking-[0.2em] uppercase">System Initializing</div>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>
    <canvas id="cam-preview"></canvas>

    <div class="ui-panel text-white">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-300 via-purple-300 to-pink-300 tracking-wide">ASTRO Â· DUST</h2>
            <div class="h-2 w-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]" id="status-dot"></div>
        </div>
        
        <p class="text-[10px] text-gray-400 mb-6 uppercase tracking-wider leading-relaxed">
            Gestural Field Control<br>
            <span class="text-gray-500">Pinch to Gather Â· Release to Scatter</span>
        </p>

        <div class="mb-6">
            <label class="block text-[10px] uppercase text-gray-500 mb-3 font-bold tracking-widest">Topology</label>
            <div class="flex flex-wrap -m-1">
                <button class="btn-shape active" onclick="switchShape('text')">SJTU</button>
                <button class="btn-shape" onclick="switchShape('heart')">Heart</button>
                <button class="btn-shape" onclick="switchShape('saturn')">Saturn</button>
            </div>
        </div>

        <div class="mb-4">
            <label class="block text-[10px] uppercase text-gray-500 mb-3 font-bold tracking-widest">Visual Effects</label>
            
            <div class="flex items-center justify-between mb-3 bg-white/5 p-2 rounded-lg border border-white/5">
                <span class="text-xs text-gray-400 font-medium">Particle Color</span>
                <div class="flex items-center space-x-2">
                    <span class="text-[10px] text-gray-500 font-mono" id="colorCode">#40c9ff</span>
                    <input type="color" id="colorPicker" value="#40c9ff" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
            </div>
        </div>
        
        <div class="mt-4 text-[10px] text-gray-600 font-mono text-center">
            Render Scale: <span id="pixel-ratio">2.0x</span>
        </div>
    </div>

<!-- ================= é¡¶ç‚¹ç€è‰²å™¨ (Vertex Shader) ================= -->
<!-- æ§åˆ¶ç²’å­çš„ä½ç½®ã€å¤§å°å’Œé—ªçƒé¢‘ç‡ -->
<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute float random;
    
    uniform float time;
    uniform float pixelRatio;
    uniform float handOpenness;
    
    varying float vAlpha;
    varying vec3 vColor;

    void main() {
        vec3 pos = position;
        
        // [å¯è°ƒå‚æ•°] æ³¢åŠ¨å¹…åº¦
        // 0.1 æ˜¯æ³¢åŠ¨çš„å¼ºåº¦ç³»æ•°ï¼Œæ•°å­—è¶Šå¤§ï¼Œç²’å­åœ¨æ‰‹å¼ å¼€æ—¶ä¸Šä¸‹æµ®åŠ¨è¶Šæ˜æ˜¾
        float wave = sin(time * 2.0 + pos.x * 0.1) * 0.1 * handOpenness;
        pos.y += wave;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        float dist = -mvPosition.z;

        // [å¯è°ƒå‚æ•°] ç²’å­é€è§†å¤§å°
        // 300.0 æ˜¯é€è§†å¼ºåº¦çš„å‚è€ƒå€¼ï¼Œå€¼è¶Šå¤§ï¼Œç¦»ç›¸æœºè¿‘çš„ç²’å­çœ‹èµ·æ¥è¶Šå¤§
        // (0.8 + 0.4 * random) è®©ç²’å­å¤§å°åœ¨ 0.8~1.2 å€ä¹‹é—´éšæœºå˜åŒ–
        gl_PointSize = size * (0.8 + 0.4 * random) * pixelRatio * (300.0 / dist);

        gl_Position = projectionMatrix * mvPosition;

        // [å¯è°ƒå‚æ•°] å‘¼å¸/é—ªçƒé€Ÿåº¦
        // è¿™é‡Œæ”¹ä¸º 1.5 (åŸä¸º 3.0)ï¼Œä½¿é—ªçƒé€Ÿåº¦æ…¢äº† 50%
        // å¦‚æœæƒ³è¦æ›´æ…¢ï¼Œå¯ä»¥æ”¹å¾—æ›´å° (ä¾‹å¦‚ 0.5)
        float twinkle = sin(time * 1.5 + random * 10.0);
        
        // [å¯è°ƒå‚æ•°] åŸºç¡€é€æ˜åº¦å’Œé—ªçƒå¹…åº¦
        // 0.6 æ˜¯åŸºç¡€ä¸é€æ˜åº¦ï¼Œ0.4 æ˜¯é—ªçƒå åŠ çš„æœ€å¤§å€¼
        vAlpha = 0.6 + 0.4 * twinkle;
    }
</script>

<!-- ================= ç‰‡å…ƒç€è‰²å™¨ (Fragment Shader) ================= -->
<!-- æ§åˆ¶ç²’å­çš„å¤–è§‚å½¢çŠ¶ (å®å¿ƒåœ†/å…‰æ™•åœ†) -->
<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    varying float vAlpha;

    void main() {
        vec2 xy = gl_PointCoord.xy - vec2(0.5);
        float r = length(xy);

        // ç¡¬åˆ‡å‰²ï¼šä¸¢å¼ƒåŠå¾„è¶…è¿‡ 0.5 çš„åƒç´ ï¼Œå½¢æˆåœ†å½¢
        if (r > 0.5) discard;

        // [å¯è°ƒå‚æ•°] è¾¹ç¼˜å¹³æ»‘åº¦ (æŠ—é”¯é½¿)
        // smoothstep(0.05, 0.08, r) 
        // è¿™é‡Œçš„æ•°å€¼å†³å®šè¾¹ç¼˜çš„é”åˆ©ç¨‹åº¦ã€‚æ•°å€¼è¶Šæ¥è¿‘ï¼Œè¾¹ç¼˜è¶Šç¡¬ã€‚
        float edge = 1.0 - smoothstep(0.05, 0.08, r);
        
        gl_FragColor = vec4(color, vAlpha * edge);
    }
</script>

<script>
    // ================= å…¨å±€é…ç½® (CONFIGURATION) =================
    // [å¯è°ƒå‚æ•°] è¿™é‡Œæ˜¯æ‰€æœ‰æ ¸å¿ƒè§†è§‰å‚æ•°çš„å…¥å£
    const CONFIG = {
        particleCount: 30000, // ç²’å­æ€»æ•°ï¼šå¤ªå¤šä¼šå¡é¡¿ï¼Œå¤ªå°‘ä¼šç¨€ç–
        baseSize: 1.2,        // ç²’å­åŸºç¡€å¤§å°ï¼šå½±å“æ¯ä¸ªç‚¹çš„è§†è§‰ç›´å¾„ (å•ä½: åƒç´ )
        defaultColor: new THREE.Color(0x40c9ff), // é»˜è®¤é¢œè‰²
        cameraZ: 25,          // æ‘„åƒæœºè·ç¦»ï¼šè¶Šå°ç‰©ä½“è¶Šè¿‘ï¼Œè¶Šå¤§ç‰©ä½“è¶Šè¿œ
        scatterRadius: 35     // æ•£å¼€èŒƒå›´ï¼šæ‰‹å¼ å¼€æ—¶ï¼Œç²’å­æœ€å¤§é£æ•£åˆ°å¤šè¿œçš„åŠå¾„
    };

    const STATE = {
        currentShape: 'text',
        targetPositions: new Float32Array(CONFIG.particleCount * 3), 
        randomOffsets: new Float32Array(CONFIG.particleCount * 3),   
        handOpenness: 1.0,  
        handPosition: { x: 0.5, y: 0.5 }, 
        handDetected: false,
        time: 0
    };

    // ================= THREE.JS æ ¸å¿ƒè®¾ç½® =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205); 
    scene.fog = new THREE.FogExp2(0x020205, 0.015); // é›¾åŒ–æ•ˆæœï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.z = CONFIG.cameraZ;

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
    renderer.setPixelRatio(pixelRatio);
    document.getElementById('pixel-ratio').innerText = pixelRatio.toFixed(1) + 'x';
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= æè´¨è®¾ç½® =================
    
    const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            color: { value: CONFIG.defaultColor },
            pixelRatio: { value: pixelRatio },
            handOpenness: { value: 1.0 }
        },
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
        transparent: true,
        depthWrite: false, 
        blending: THREE.AdditiveBlending 
    });

    // ================= ç²’å­å‡ ä½•ä½“ç”Ÿæˆ =================

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const randoms = new Float32Array(CONFIG.particleCount); 
    const sizes = new Float32Array(CONFIG.particleCount);   
    
    // åˆå§‹åŒ–ç²’å­
    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åˆå§‹éšæœºåˆ†å¸ƒ (çƒå½¢)
        const r = CONFIG.scatterRadius * (0.5 + Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i*3+2] = r * Math.cos(phi);

        STATE.randomOffsets[i*3] = positions[i*3];
        STATE.randomOffsets[i*3+1] = positions[i*3+1];
        STATE.randomOffsets[i*3+2] = positions[i*3+2];

        randoms[i] = Math.random();
        sizes[i] = CONFIG.baseSize * (0.5 + Math.random());
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particles = new THREE.Points(geometry, shaderMaterial);
    scene.add(particles);

    // ================= å½¢çŠ¶ç”Ÿæˆé€»è¾‘ =================

    function getPointsFromText(textString) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; 
        canvas.height = 200;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFFFF';
        // [å¯è°ƒå‚æ•°] å­—ä½“å¤§å°å’Œæ ·å¼
        ctx.font = '900 100px "Segoe UI", Arial, sans-serif'; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(textString, canvas.width / 2, canvas.height / 2);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const validPoints = [];
        
        // [å¯è°ƒå‚æ•°] é‡‡æ ·æ­¥é•¿ (y += 3, x += 3)
        // æ­¥é•¿è¶Šå°ï¼Œé‡‡æ ·ç‚¹è¶Šå¯†ï¼Œæ–‡å­—è¶Šæ¸…æ™°ï¼Œä½†éœ€è¦çš„ç²’å­æ•°æ›´å¤š
        for (let y = 0; y < canvas.height; y += 3) {
            for (let x = 0; x < canvas.width; x += 3) {
                if (data[(y * canvas.width + x) * 4] > 50) {
                    // [å¯è°ƒå‚æ•°] æ–‡å­—çš„ä¸–ç•Œåæ ‡ç¼©æ”¾ (0.06)
                    const worldX = (x - canvas.width / 2) * 0.06; 
                    const worldY = -(y - canvas.height / 2) * 0.06; 
                    validPoints.push({x: worldX, y: worldY});
                }
            }
        }
        return validPoints;
    }

    function generateTargetPositions(shapeType) {
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const count = CONFIG.particleCount;
        let textPoints = [];
        
        if (shapeType === 'text') {
            textPoints = getPointsFromText("I â¤ï¸ SJTU");
        }

        for (let i = 0; i < count; i++) {
            let x, y, z;
            const idx = i * 3;

            if (shapeType === 'heart') {
                const t = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()); 
                // [å¯è°ƒå‚æ•°] çˆ±å¿ƒå½¢çŠ¶å…¬å¼ç³»æ•°
                let px = 16 * Math.pow(Math.sin(t), 3);
                let py = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                x = px * r * 0.5;
                y = py * r * 0.5;
                z = (Math.random() - 0.5) * 5 * r; 

            } else if (shapeType === 'saturn') {
                const ratio = i / count;
                if (ratio < 0.6) { // 60% ç²’å­åšæ˜Ÿçƒä¸»ä½“
                    const phi = Math.acos(-1 + (2 * i / (count * 0.6)));
                    const theta = Math.sqrt((count * 0.6) * Math.PI) * phi;
                    const r = 5;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } else { // 40% ç²’å­åšå…‰ç¯
                    const angle = Math.random() * Math.PI * 2;
                    const r = 8 + Math.random() * 6; // å…‰ç¯åŠå¾„èŒƒå›´ 8~14
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle); 
                    y = (Math.random() - 0.5) * 0.3; // å…‰ç¯åšåº¦
                    const tilt = 0.4; // å€¾æ–œè§’
                    const y_new = y * Math.cos(tilt) - x * Math.sin(tilt);
                    const x_new = y * Math.sin(tilt) + x * Math.cos(tilt);
                    x = x_new;
                    y = y_new;
                }
            } else if (shapeType === 'text') {
                if (textPoints.length > 0) {
                    const p = textPoints[i % textPoints.length];
                    x = p.x;
                    y = p.y;
                    // [å¯è°ƒå‚æ•°] æ–‡å­—çš„ 3D åšåº¦ (2.0)
                    z = (Math.random() - 0.5) * 2.0;
                } else {
                    x = (Math.random() - 0.5) * 20;
                    y = (Math.random() - 0.5) * 20;
                    z = (Math.random() - 0.5) * 20;
                }
            }

            targets[idx] = x;
            targets[idx + 1] = y;
            targets[idx + 2] = z;
        }
        return targets;
    }

    STATE.targetPositions = generateTargetPositions(STATE.currentShape);

    // ================= MEDIA PIPE æ‰‹åŠ¿è¯†åˆ« =================
    
    const videoElement = document.getElementById('video-input');
    const previewCanvas = document.getElementById('cam-preview');
    const previewCtx = previewCanvas.getContext('2d');
    
    previewCtx.translate(previewCanvas.width, 0);
    previewCtx.scale(-1, 1);

    function onResults(results) {
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            STATE.handDetected = true;
            document.getElementById('status-dot').className = "h-2 w-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]";
            document.getElementById('loading').style.display = 'none';

            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#40c9ff', lineWidth: 1});

            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20].map(i => landmarks[i]);
            const dists = tips.map(tip => Math.hypot(tip.x - wrist.x, tip.y - wrist.y));
            const avgDist = dists.reduce((a, b) => a + b) / 5;
            
            // [å¯è°ƒå‚æ•°] æ‰‹åŠ¿å¼ åˆçµæ•åº¦æ˜ å°„
            // 0.2 æ˜¯æ¡æ‹³æ—¶çš„é¢„ä¼°è·ç¦»ï¼Œ3.3 æ˜¯æ”¾å¤§å€æ•°
            let rawOpenness = (avgDist - 0.2) * 3.3; 
            rawOpenness = Math.max(0, Math.min(1, rawOpenness));
            
            STATE.handOpenness += (rawOpenness - STATE.handOpenness) * 0.1;

            const mid = landmarks[9];
            const handX = (wrist.x + mid.x) / 2;
            const handY = (wrist.y + mid.y) / 2;
            
            STATE.handPosition.x += (handX - STATE.handPosition.x) * 0.1;
            STATE.handPosition.y += (handY - STATE.handPosition.y) * 0.1;

        } else {
            STATE.handDetected = false;
            document.getElementById('status-dot').className = "h-2 w-2 rounded-full bg-yellow-500";
            STATE.handOpenness += (0.0 - STATE.handOpenness) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ (ANIMATION LOOP) =================
    
    function animate() {
        requestAnimationFrame(animate);

        // [å¯è°ƒå‚æ•°] åŠ¨ç”»æ—¶é—´æ­¥é•¿ (0.03)
        // å½±å“æ‰€æœ‰åŸºäºæ—¶é—´çš„åŠ¨ç”»ï¼ˆå¦‚é—ªçƒã€æ³¢æµªã€æ¼‚æµ®ï¼‰çš„é€Ÿåº¦
        const dt = 0.03;
        STATE.time += dt;
        
        shaderMaterial.uniforms.time.value = STATE.time;
        shaderMaterial.uniforms.handOpenness.value = STATE.handOpenness;

        const positionsArray = particles.geometry.attributes.position.array;
        
        // æ—‹è½¬é€»è¾‘
        if (STATE.handDetected) {
            // [å¯è°ƒå‚æ•°] æ‰‹åŠ¿æ—‹è½¬çµæ•åº¦
            // ç³»æ•°è¶Šå¤§ï¼Œæ‰‹ç§»åŠ¨ä¸€ç‚¹ç‚¹ï¼Œç‰©ä½“æ—‹è½¬å¹…åº¦å°±è¶Šå¤§
            const targetRotY = -(STATE.handPosition.x - 0.5) * 3.0; 
            const targetRotX = (STATE.handPosition.y - 0.5) * 2.5; 
            
            // 0.1 æ˜¯æ—‹è½¬è·Ÿéšçš„å¹³æ»‘ç³»æ•°
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.1;
        } else {
            // [å¯è°ƒå‚æ•°] å¾…æœºè‡ªåŠ¨æ—‹è½¬é€Ÿåº¦
            particles.rotation.y += 0.001; 
            particles.rotation.x += (0 - particles.rotation.x) * 0.05;
        }

        const openness = STATE.handOpenness; // 0 (æ¡æ‹³) -> 1 (å¼ æ‰‹)
        
        // [å¯è°ƒå‚æ•°] ç²’å­ç§»åŠ¨é€Ÿåº¦/æ’å€¼ç³»æ•° (0.1)
        // å€¼è¶Šå¤§ï¼Œç²’å­é£å‘ç›®æ ‡ä½ç½®çš„é€Ÿåº¦è¶Šå¿«ï¼Œååº”è¶Šçµæ•ï¼Œä½†å¯èƒ½è¶Šç”Ÿç¡¬
        const lerpFactor = 0.1; 

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            
            // ç›®æ ‡ä½ç½® A: å…·ä½“çš„å½¢çŠ¶ (Text, Heart, Saturn)
            const tx = STATE.targetPositions[i3];
            const ty = STATE.targetPositions[i3+1];
            const tz = STATE.targetPositions[i3+2];

            // ç›®æ ‡ä½ç½® B: æ•£å¼€çš„æ˜Ÿå°˜çŠ¶æ€
            // [å¯è°ƒå‚æ•°] æ¼‚æµ®åŠ¨ç”»å‚æ•°
            // sin(STATE.time * 0.5) æ§åˆ¶æ¼‚æµ®çš„é¢‘ç‡ï¼Œ* 2.0 æ§åˆ¶æ¼‚æµ®çš„å¹…åº¦
            const rx = STATE.randomOffsets[i3] + Math.sin(STATE.time * 0.5 + i) * 2.0;
            const ry = STATE.randomOffsets[i3+1] + Math.cos(STATE.time * 0.3 + i) * 2.0;
            const rz = STATE.randomOffsets[i3+2];

            // [å¯è°ƒå‚æ•°] æ··åˆæ›²çº¿
            // openness * openness æ˜¯ä¸€ç§éçº¿æ€§æ··åˆï¼Œä½¿å¾—æ‰‹æŒåˆšå¼ å¼€æ—¶ç²’å­æ•£å¼€å¾—æ…¢ï¼Œå®Œå…¨å¼ å¼€æ—¶æ•£å¾—è¿œ
            const mixRatio = openness * openness; 

            // è®¡ç®—è¿™ä¸€å¸§çš„æœ€ç»ˆç›®æ ‡ä½ç½® (åœ¨ A å’Œ B ä¹‹é—´æ··åˆ)
            const destX = tx * (1.0 - mixRatio) + rx * mixRatio;
            const destY = ty * (1.0 - mixRatio) + ry * mixRatio;
            const destZ = tz * (1.0 - mixRatio) + rz * mixRatio;

            // æ›´æ–°ç²’å­ä½ç½®
            positionsArray[i3]   += (destX - positionsArray[i3]) * lerpFactor;
            positionsArray[i3+1] += (destY - positionsArray[i3+1]) * lerpFactor;
            positionsArray[i3+2] += (destZ - positionsArray[i3+2]) * lerpFactor;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    // ================= äº¤äº’äº‹ä»¶ =================

    window.switchShape = (shape) => {
        STATE.currentShape = shape;
        STATE.targetPositions = generateTargetPositions(shape);
        
        document.querySelectorAll('.btn-shape').forEach(btn => {
            btn.classList.remove('active');
            if(btn.innerText.toLowerCase().includes(shape === 'text' ? 'sjtu' : shape)) {
                btn.classList.add('active');
            }
        });
    };

    document.getElementById('colorPicker').addEventListener('input', (e) => {
        const hex = e.target.value;
        document.getElementById('colorCode').innerText = hex;
        shaderMaterial.uniforms.color.value = new THREE.Color(hex);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const newPixel = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(newPixel);
        shaderMaterial.uniforms.pixelRatio.value = newPixel;
        document.getElementById('pixel-ratio').innerText = newPixel.toFixed(1) + 'x';
    });
    
</script>
</body>
</html>
```

