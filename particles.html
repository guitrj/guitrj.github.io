---
layout: null
permalink: /particles/
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 手势交互粒子系统 v4.4 (Slow Breath & Comments)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; visibility: hidden; width: 320px; height: 240px; transform: scaleX(-1); }
        
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(10, 10, 15, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 24px;
            border-radius: 20px;
            width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            transition: opacity 0.3s;
        }

        .btn-shape {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            padding: 8px 14px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        .btn-shape:hover, .btn-shape.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }
        .btn-shape.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.6);
            color: #e0f2fe;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            pointer-events: none;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #cam-preview {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 135px;
            z-index: 5;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            background: #000;
            opacity: 0.7;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }
        #cam-preview:hover { opacity: 1; }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div class="text-gray-400 text-xs tracking-[0.2em] uppercase">System Initializing</div>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>
    <canvas id="cam-preview"></canvas>

    <div class="ui-panel text-white">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-300 via-purple-300 to-pink-300 tracking-wide">ASTRO · DUST</h2>
            <div class="h-2 w-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]" id="status-dot"></div>
        </div>
        
        <p class="text-[10px] text-gray-400 mb-6 uppercase tracking-wider leading-relaxed">
            Gestural Field Control<br>
            <span class="text-gray-500">Pinch to Gather · Release to Scatter</span>
        </p>

        <div class="mb-6">
            <label class="block text-[10px] uppercase text-gray-500 mb-3 font-bold tracking-widest">Topology</label>
            <div class="flex flex-wrap -m-1">
                <button class="btn-shape active" onclick="switchShape('text')">SJTU</button>
                <button class="btn-shape" onclick="switchShape('heart')">Heart</button>
                <button class="btn-shape" onclick="switchShape('saturn')">Saturn</button>
            </div>
        </div>

        <div class="mb-4">
            <label class="block text-[10px] uppercase text-gray-500 mb-3 font-bold tracking-widest">Visual Effects</label>
            
            <div class="flex items-center justify-between mb-3 bg-white/5 p-2 rounded-lg border border-white/5">
                <span class="text-xs text-gray-400 font-medium">Particle Color</span>
                <div class="flex items-center space-x-2">
                    <span class="text-[10px] text-gray-500 font-mono" id="colorCode">#40c9ff</span>
                    <input type="color" id="colorPicker" value="#40c9ff" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
            </div>
        </div>
        
        <div class="mt-4 text-[10px] text-gray-600 font-mono text-center">
            Render Scale: <span id="pixel-ratio">2.0x</span>
        </div>
    </div>

<!-- ================= 顶点着色器 (Vertex Shader) ================= -->
<!-- 控制粒子的位置、大小和闪烁频率 -->
<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute float random;
    
    uniform float time;
    uniform float pixelRatio;
    uniform float handOpenness;
    
    varying float vAlpha;
    varying vec3 vColor;

    void main() {
        vec3 pos = position;
        
        // [可调参数] 波动幅度
        // 0.1 是波动的强度系数，数字越大，粒子在手张开时上下浮动越明显
        float wave = sin(time * 2.0 + pos.x * 0.1) * 0.1 * handOpenness;
        pos.y += wave;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        float dist = -mvPosition.z;

        // [可调参数] 粒子透视大小
        // 300.0 是透视强度的参考值，值越大，离相机近的粒子看起来越大
        // (0.8 + 0.4 * random) 让粒子大小在 0.8~1.2 倍之间随机变化
        gl_PointSize = size * (0.8 + 0.4 * random) * pixelRatio * (300.0 / dist);

        gl_Position = projectionMatrix * mvPosition;

        // [可调参数] 呼吸/闪烁速度
        // 这里改为 1.5 (原为 3.0)，使闪烁速度慢了 50%
        // 如果想要更慢，可以改得更小 (例如 0.5)
        float twinkle = sin(time * 1.5 + random * 10.0);
        
        // [可调参数] 基础透明度和闪烁幅度
        // 0.6 是基础不透明度，0.4 是闪烁叠加的最大值
        vAlpha = 0.6 + 0.4 * twinkle;
    }
</script>

<!-- ================= 片元着色器 (Fragment Shader) ================= -->
<!-- 控制粒子的外观形状 (实心圆/光晕圆) -->
<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    varying float vAlpha;

    void main() {
        vec2 xy = gl_PointCoord.xy - vec2(0.5);
        float r = length(xy);

        // 硬切割：丢弃半径超过 0.5 的像素，形成圆形
        if (r > 0.5) discard;

        // [可调参数] 边缘平滑度 (抗锯齿)
        // smoothstep(0.05, 0.08, r) 
        // 这里的数值决定边缘的锐利程度。数值越接近，边缘越硬。
        float edge = 1.0 - smoothstep(0.05, 0.08, r);
        
        gl_FragColor = vec4(color, vAlpha * edge);
    }
</script>

<script>
    // ================= 全局配置 (CONFIGURATION) =================
    // [可调参数] 这里是所有核心视觉参数的入口
    const CONFIG = {
        particleCount: 30000, // 粒子总数：太多会卡顿，太少会稀疏
        baseSize: 1.2,        // 粒子基础大小：影响每个点的视觉直径 (单位: 像素)
        defaultColor: new THREE.Color(0x40c9ff), // 默认颜色
        cameraZ: 25,          // 摄像机距离：越小物体越近，越大物体越远
        scatterRadius: 35     // 散开范围：手张开时，粒子最大飞散到多远的半径
    };

    const STATE = {
        currentShape: 'text',
        targetPositions: new Float32Array(CONFIG.particleCount * 3), 
        randomOffsets: new Float32Array(CONFIG.particleCount * 3),   
        handOpenness: 1.0,  
        handPosition: { x: 0.5, y: 0.5 }, 
        handDetected: false,
        time: 0
    };

    // ================= THREE.JS 核心设置 =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205); 
    scene.fog = new THREE.FogExp2(0x020205, 0.015); // 雾化效果，增加深邃感

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.z = CONFIG.cameraZ;

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
    renderer.setPixelRatio(pixelRatio);
    document.getElementById('pixel-ratio').innerText = pixelRatio.toFixed(1) + 'x';
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= 材质设置 =================
    
    const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            color: { value: CONFIG.defaultColor },
            pixelRatio: { value: pixelRatio },
            handOpenness: { value: 1.0 }
        },
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
        transparent: true,
        depthWrite: false, 
        blending: THREE.AdditiveBlending 
    });

    // ================= 粒子几何体生成 =================

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const randoms = new Float32Array(CONFIG.particleCount); 
    const sizes = new Float32Array(CONFIG.particleCount);   
    
    // 初始化粒子
    for (let i = 0; i < CONFIG.particleCount; i++) {
        // 初始随机分布 (球形)
        const r = CONFIG.scatterRadius * (0.5 + Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i*3+2] = r * Math.cos(phi);

        STATE.randomOffsets[i*3] = positions[i*3];
        STATE.randomOffsets[i*3+1] = positions[i*3+1];
        STATE.randomOffsets[i*3+2] = positions[i*3+2];

        randoms[i] = Math.random();
        sizes[i] = CONFIG.baseSize * (0.5 + Math.random());
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particles = new THREE.Points(geometry, shaderMaterial);
    scene.add(particles);

    // ================= 形状生成逻辑 =================

    function getPointsFromText(textString) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; 
        canvas.height = 200;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFFFF';
        // [可调参数] 字体大小和样式
        ctx.font = '900 100px "Segoe UI", Arial, sans-serif'; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(textString, canvas.width / 2, canvas.height / 2);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const validPoints = [];
        
        // [可调参数] 采样步长 (y += 3, x += 3)
        // 步长越小，采样点越密，文字越清晰，但需要的粒子数更多
        for (let y = 0; y < canvas.height; y += 3) {
            for (let x = 0; x < canvas.width; x += 3) {
                if (data[(y * canvas.width + x) * 4] > 50) {
                    // [可调参数] 文字的世界坐标缩放 (0.06)
                    const worldX = (x - canvas.width / 2) * 0.06; 
                    const worldY = -(y - canvas.height / 2) * 0.06; 
                    validPoints.push({x: worldX, y: worldY});
                }
            }
        }
        return validPoints;
    }

    function generateTargetPositions(shapeType) {
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const count = CONFIG.particleCount;
        let textPoints = [];
        
        if (shapeType === 'text') {
            textPoints = getPointsFromText("I ❤️ SJTU");
        }

        for (let i = 0; i < count; i++) {
            let x, y, z;
            const idx = i * 3;

            if (shapeType === 'heart') {
                const t = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()); 
                // [可调参数] 爱心形状公式系数
                let px = 16 * Math.pow(Math.sin(t), 3);
                let py = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                x = px * r * 0.5;
                y = py * r * 0.5;
                z = (Math.random() - 0.5) * 5 * r; 

            } else if (shapeType === 'saturn') {
                const ratio = i / count;
                if (ratio < 0.6) { // 60% 粒子做星球主体
                    const phi = Math.acos(-1 + (2 * i / (count * 0.6)));
                    const theta = Math.sqrt((count * 0.6) * Math.PI) * phi;
                    const r = 5;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } else { // 40% 粒子做光环
                    const angle = Math.random() * Math.PI * 2;
                    const r = 8 + Math.random() * 6; // 光环半径范围 8~14
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle); 
                    y = (Math.random() - 0.5) * 0.3; // 光环厚度
                    const tilt = 0.4; // 倾斜角
                    const y_new = y * Math.cos(tilt) - x * Math.sin(tilt);
                    const x_new = y * Math.sin(tilt) + x * Math.cos(tilt);
                    x = x_new;
                    y = y_new;
                }
            } else if (shapeType === 'text') {
                if (textPoints.length > 0) {
                    const p = textPoints[i % textPoints.length];
                    x = p.x;
                    y = p.y;
                    // [可调参数] 文字的 3D 厚度 (2.0)
                    z = (Math.random() - 0.5) * 2.0;
                } else {
                    x = (Math.random() - 0.5) * 20;
                    y = (Math.random() - 0.5) * 20;
                    z = (Math.random() - 0.5) * 20;
                }
            }

            targets[idx] = x;
            targets[idx + 1] = y;
            targets[idx + 2] = z;
        }
        return targets;
    }

    STATE.targetPositions = generateTargetPositions(STATE.currentShape);

    // ================= MEDIA PIPE 手势识别 =================
    
    const videoElement = document.getElementById('video-input');
    const previewCanvas = document.getElementById('cam-preview');
    const previewCtx = previewCanvas.getContext('2d');
    
    previewCtx.translate(previewCanvas.width, 0);
    previewCtx.scale(-1, 1);

    function onResults(results) {
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            STATE.handDetected = true;
            document.getElementById('status-dot').className = "h-2 w-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]";
            document.getElementById('loading').style.display = 'none';

            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#40c9ff', lineWidth: 1});

            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20].map(i => landmarks[i]);
            const dists = tips.map(tip => Math.hypot(tip.x - wrist.x, tip.y - wrist.y));
            const avgDist = dists.reduce((a, b) => a + b) / 5;
            
            // [可调参数] 手势张合灵敏度映射
            // 0.2 是握拳时的预估距离，3.3 是放大倍数
            let rawOpenness = (avgDist - 0.2) * 3.3; 
            rawOpenness = Math.max(0, Math.min(1, rawOpenness));
            
            STATE.handOpenness += (rawOpenness - STATE.handOpenness) * 0.1;

            const mid = landmarks[9];
            const handX = (wrist.x + mid.x) / 2;
            const handY = (wrist.y + mid.y) / 2;
            
            STATE.handPosition.x += (handX - STATE.handPosition.x) * 0.1;
            STATE.handPosition.y += (handY - STATE.handPosition.y) * 0.1;

        } else {
            STATE.handDetected = false;
            document.getElementById('status-dot').className = "h-2 w-2 rounded-full bg-yellow-500";
            STATE.handOpenness += (0.0 - STATE.handOpenness) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= 动画循环 (ANIMATION LOOP) =================
    
    function animate() {
        requestAnimationFrame(animate);

        // [可调参数] 动画时间步长 (0.03)
        // 影响所有基于时间的动画（如闪烁、波浪、漂浮）的速度
        const dt = 0.03;
        STATE.time += dt;
        
        shaderMaterial.uniforms.time.value = STATE.time;
        shaderMaterial.uniforms.handOpenness.value = STATE.handOpenness;

        const positionsArray = particles.geometry.attributes.position.array;
        
        // 旋转逻辑
        if (STATE.handDetected) {
            // [可调参数] 手势旋转灵敏度
            // 系数越大，手移动一点点，物体旋转幅度就越大
            const targetRotY = -(STATE.handPosition.x - 0.5) * 3.0; 
            const targetRotX = (STATE.handPosition.y - 0.5) * 2.5; 
            
            // 0.1 是旋转跟随的平滑系数
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.1;
        } else {
            // [可调参数] 待机自动旋转速度
            particles.rotation.y += 0.001; 
            particles.rotation.x += (0 - particles.rotation.x) * 0.05;
        }

        const openness = STATE.handOpenness; // 0 (握拳) -> 1 (张手)
        
        // [可调参数] 粒子移动速度/插值系数 (0.1)
        // 值越大，粒子飞向目标位置的速度越快，反应越灵敏，但可能越生硬
        const lerpFactor = 0.1; 

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            
            // 目标位置 A: 具体的形状 (Text, Heart, Saturn)
            const tx = STATE.targetPositions[i3];
            const ty = STATE.targetPositions[i3+1];
            const tz = STATE.targetPositions[i3+2];

            // 目标位置 B: 散开的星尘状态
            // [可调参数] 漂浮动画参数
            // sin(STATE.time * 0.5) 控制漂浮的频率，* 2.0 控制漂浮的幅度
            const rx = STATE.randomOffsets[i3] + Math.sin(STATE.time * 0.5 + i) * 2.0;
            const ry = STATE.randomOffsets[i3+1] + Math.cos(STATE.time * 0.3 + i) * 2.0;
            const rz = STATE.randomOffsets[i3+2];

            // [可调参数] 混合曲线
            // openness * openness 是一种非线性混合，使得手掌刚张开时粒子散开得慢，完全张开时散得远
            const mixRatio = openness * openness; 

            // 计算这一帧的最终目标位置 (在 A 和 B 之间混合)
            const destX = tx * (1.0 - mixRatio) + rx * mixRatio;
            const destY = ty * (1.0 - mixRatio) + ry * mixRatio;
            const destZ = tz * (1.0 - mixRatio) + rz * mixRatio;

            // 更新粒子位置
            positionsArray[i3]   += (destX - positionsArray[i3]) * lerpFactor;
            positionsArray[i3+1] += (destY - positionsArray[i3+1]) * lerpFactor;
            positionsArray[i3+2] += (destZ - positionsArray[i3+2]) * lerpFactor;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    // ================= 交互事件 =================

    window.switchShape = (shape) => {
        STATE.currentShape = shape;
        STATE.targetPositions = generateTargetPositions(shape);
        
        document.querySelectorAll('.btn-shape').forEach(btn => {
            btn.classList.remove('active');
            if(btn.innerText.toLowerCase().includes(shape === 'text' ? 'sjtu' : shape)) {
                btn.classList.add('active');
            }
        });
    };

    document.getElementById('colorPicker').addEventListener('input', (e) => {
        const hex = e.target.value;
        document.getElementById('colorCode').innerText = hex;
        shaderMaterial.uniforms.color.value = new THREE.Color(hex);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const newPixel = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(newPixel);
        shaderMaterial.uniforms.pixelRatio.value = newPixel;
        document.getElementById('pixel-ratio').innerText = newPixel.toFixed(1) + 'x';
    });
    
</script>
</body>
</html>